<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Between Tokens: Vibe Flapping</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            background: #1e1e1e;
            font-family: monospace;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: #fff;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            z-index: 10;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            z-index: 20;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border: 4px solid #fff;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="score-display" id="score">0</div>
        <div class="message hidden" id="message">PAUSED</div>
        <canvas id="game"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const messageEl = document.getElementById('message');

        // Game constants
        const GRAVITY = 0.3;
        const FLAP_STRENGTH = -8;
        const PIPE_SPEED = 3;
        const PIPE_GAP = 200;
        const PIPE_WIDTH = 60;
        const PIPE_SPAWN_INTERVAL = 90;
        const FIRST_PIPE_DELAY = 30;
        const GROUND_HEIGHT = 80;

        // Resize canvas to fill window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Colors - Retro palette
        const COLORS = {
            sky: '#70c5ce',
            ground: '#ded895',
            groundDark: '#c4a35a',
            pipe: '#73bf2e',
            pipeLight: '#8fd54a',
            pipeDark: '#548c1f',
            pipeCap: '#73bf2e',
            bird: '#f7dc6f',
            birdDark: '#d4ac0d',
            birdBeak: '#e74c3c',
            birdEye: '#fff',
            birdPupil: '#000'
        };

        // Game state
        let gameState = 'waiting'; // waiting, playing, paused, gameover
        let bird = { x: 80, y: canvas.height / 2, velocity: 0, rotation: 0 };
        let pipes = [];
        let score = 0;
        let frameCount = 0;
        let groundOffset = 0;

        // Bird animation
        let wingFrame = 0;
        let wingTimer = 0;

        function resetGame() {
            bird = { x: 80, y: canvas.height / 2, velocity: 0, rotation: 0 };
            pipes = [];
            score = 0;
            frameCount = 0;
            scoreDisplay.textContent = '0';
        }

        function flap() {
            if (gameState === 'playing') {
                bird.velocity = FLAP_STRENGTH;
            } else if (gameState === 'waiting' || gameState === 'gameover') {
                resetGame();
                gameState = 'playing';
                messageEl.classList.add('hidden');
            }
        }

        function spawnPipe() {
            const minY = 80;
            const maxY = canvas.height - GROUND_HEIGHT - PIPE_GAP - 80;
            const gapY = minY + Math.random() * (maxY - minY);

            pipes.push({
                x: canvas.width,
                gapY: gapY,
                passed: false
            });
        }

        function drawPixelRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
        }

        function drawBird() {
            const bx = Math.floor(bird.x);
            const by = Math.floor(bird.y);

            ctx.save();
            ctx.translate(bx + 17, by + 12);
            ctx.rotate(Math.min(Math.max(bird.rotation, -0.5), 1.2));
            ctx.translate(-(bx + 17), -(by + 12));

            // Body
            drawPixelRect(bx, by + 4, 34, 20, COLORS.bird);
            drawPixelRect(bx + 2, by + 2, 30, 2, COLORS.bird);
            drawPixelRect(bx + 2, by + 24, 30, 2, COLORS.bird);

            // Darker underside
            drawPixelRect(bx + 2, by + 18, 28, 6, COLORS.birdDark);

            // Wing
            const wingY = wingFrame === 0 ? by + 10 : (wingFrame === 1 ? by + 8 : by + 12);
            drawPixelRect(bx + 4, wingY, 16, 8, COLORS.birdDark);

            // Eye
            drawPixelRect(bx + 22, by + 4, 10, 10, COLORS.birdEye);
            drawPixelRect(bx + 26, by + 6, 4, 6, COLORS.birdPupil);

            // Beak
            drawPixelRect(bx + 30, by + 12, 10, 6, COLORS.birdBeak);
            drawPixelRect(bx + 34, by + 14, 8, 2, '#c0392b');

            ctx.restore();
        }

        function drawPipe(pipe) {
            const capHeight = 26;
            const capOverhang = 6;

            // Top pipe
            const topPipeHeight = pipe.gapY;
            drawPixelRect(pipe.x, 0, PIPE_WIDTH, topPipeHeight, COLORS.pipe);
            // Highlight
            drawPixelRect(pipe.x + 4, 0, 8, topPipeHeight, COLORS.pipeLight);
            // Shadow
            drawPixelRect(pipe.x + PIPE_WIDTH - 8, 0, 8, topPipeHeight, COLORS.pipeDark);
            // Cap
            drawPixelRect(pipe.x - capOverhang, topPipeHeight - capHeight, PIPE_WIDTH + capOverhang * 2, capHeight, COLORS.pipe);
            drawPixelRect(pipe.x - capOverhang + 4, topPipeHeight - capHeight, 8, capHeight, COLORS.pipeLight);
            drawPixelRect(pipe.x + PIPE_WIDTH + capOverhang - 8, topPipeHeight - capHeight, 8, capHeight, COLORS.pipeDark);
            // Cap border
            drawPixelRect(pipe.x - capOverhang, topPipeHeight - capHeight, PIPE_WIDTH + capOverhang * 2, 4, COLORS.pipeDark);
            drawPixelRect(pipe.x - capOverhang, topPipeHeight - 4, PIPE_WIDTH + capOverhang * 2, 4, COLORS.pipeDark);

            // Bottom pipe
            const bottomPipeY = pipe.gapY + PIPE_GAP;
            const bottomPipeHeight = canvas.height - bottomPipeY - GROUND_HEIGHT;
            drawPixelRect(pipe.x, bottomPipeY, PIPE_WIDTH, bottomPipeHeight, COLORS.pipe);
            // Highlight
            drawPixelRect(pipe.x + 4, bottomPipeY, 8, bottomPipeHeight, COLORS.pipeLight);
            // Shadow
            drawPixelRect(pipe.x + PIPE_WIDTH - 8, bottomPipeY, 8, bottomPipeHeight, COLORS.pipeDark);
            // Cap
            drawPixelRect(pipe.x - capOverhang, bottomPipeY, PIPE_WIDTH + capOverhang * 2, capHeight, COLORS.pipe);
            drawPixelRect(pipe.x - capOverhang + 4, bottomPipeY, 8, capHeight, COLORS.pipeLight);
            drawPixelRect(pipe.x + PIPE_WIDTH + capOverhang - 8, bottomPipeY, 8, capHeight, COLORS.pipeDark);
            // Cap border
            drawPixelRect(pipe.x - capOverhang, bottomPipeY, PIPE_WIDTH + capOverhang * 2, 4, COLORS.pipeDark);
            drawPixelRect(pipe.x - capOverhang, bottomPipeY + capHeight - 4, PIPE_WIDTH + capOverhang * 2, 4, COLORS.pipeDark);
        }

        function drawGround() {
            // Main ground
            drawPixelRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT, COLORS.ground);

            // Ground pattern
            for (let i = -1; i < canvas.width / 24 + 1; i++) {
                const x = (i * 24 - groundOffset % 24);
                drawPixelRect(x, canvas.height - GROUND_HEIGHT, 12, 20, COLORS.groundDark);
            }

            // Ground top edge
            drawPixelRect(0, canvas.height - GROUND_HEIGHT, canvas.width, 4, COLORS.groundDark);
        }

        function drawBackground() {
            // Sky
            ctx.fillStyle = COLORS.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Simple clouds spread across the canvas
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const cloudSpacing = 200;
            for (let i = 0; i < canvas.width / cloudSpacing + 1; i++) {
                const baseX = i * cloudSpacing;
                const offsetY = (i % 3) * 40;
                drawCloud(baseX + 50, 60 + offsetY);
            }
        }

        function drawCloud(x, y) {
            drawPixelRect(x, y, 40, 16, 'rgba(255, 255, 255, 0.8)');
            drawPixelRect(x + 8, y - 8, 24, 8, 'rgba(255, 255, 255, 0.8)');
            drawPixelRect(x - 8, y + 4, 16, 8, 'rgba(255, 255, 255, 0.6)');
            drawPixelRect(x + 32, y + 4, 16, 8, 'rgba(255, 255, 255, 0.6)');
        }

        function checkCollision() {
            const birdBox = {
                x: bird.x + 4,
                y: bird.y + 4,
                width: 26,
                height: 20
            };

            // Ground collision
            if (bird.y + 24 > canvas.height - GROUND_HEIGHT) {
                return true;
            }

            // Ceiling collision
            if (bird.y < 0) {
                return true;
            }

            // Pipe collision
            for (const pipe of pipes) {
                const capOverhang = 6;

                // Top pipe
                if (birdBox.x + birdBox.width > pipe.x - capOverhang &&
                    birdBox.x < pipe.x + PIPE_WIDTH + capOverhang &&
                    birdBox.y < pipe.gapY) {
                    return true;
                }

                // Bottom pipe
                if (birdBox.x + birdBox.width > pipe.x - capOverhang &&
                    birdBox.x < pipe.x + PIPE_WIDTH + capOverhang &&
                    birdBox.y + birdBox.height > pipe.gapY + PIPE_GAP) {
                    return true;
                }
            }

            return false;
        }

        function update() {
            if (gameState !== 'playing') return;

            frameCount++;

            // Bird physics
            bird.velocity += GRAVITY;
            bird.y += bird.velocity;
            bird.rotation = bird.velocity * 0.04;

            // Wing animation
            wingTimer++;
            if (wingTimer > 5) {
                wingTimer = 0;
                wingFrame = (wingFrame + 1) % 3;
            }

            // Ground scroll
            groundOffset += PIPE_SPEED;

            // Spawn pipes
            if (frameCount === FIRST_PIPE_DELAY || (frameCount > FIRST_PIPE_DELAY && (frameCount - FIRST_PIPE_DELAY) % PIPE_SPAWN_INTERVAL === 0)) {
                spawnPipe();
            }

            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= PIPE_SPEED;

                // Score
                if (!pipes[i].passed && pipes[i].x + PIPE_WIDTH < bird.x) {
                    pipes[i].passed = true;
                    score++;
                    scoreDisplay.textContent = score.toString();
                }

                // Remove off-screen pipes
                if (pipes[i].x + PIPE_WIDTH < -10) {
                    pipes.splice(i, 1);
                }
            }

            // Collision
            if (checkCollision()) {
                gameState = 'gameover';
                messageEl.textContent = 'GAME OVER';
                messageEl.classList.remove('hidden');
            }
        }

        function draw() {
            drawBackground();

            for (const pipe of pipes) {
                drawPipe(pipe);
            }

            drawGround();
            drawBird();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Input handlers
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                flap();
            }
        });

        canvas.addEventListener('click', flap);

        // VS Code extension message handler
        window.addEventListener('message', (event) => {
            const message = event.data;

            if (message.type === 'start') {
                if (gameState === 'paused') {
                    gameState = 'playing';
                    messageEl.classList.add('hidden');
                } else if (gameState === 'waiting' || gameState === 'gameover') {
                    resetGame();
                    gameState = 'playing';
                    messageEl.classList.add('hidden');
                }
            } else if (message.type === 'pause') {
                if (gameState === 'playing') {
                    gameState = 'paused';
                    messageEl.textContent = 'PAUSED';
                    messageEl.classList.remove('hidden');
                }
            }
        });

        // Start with waiting message
        messageEl.textContent = 'WAITING FOR PROMPT...';
        messageEl.classList.remove('hidden');

        // Start game loop
        gameLoop();
    </script>
</body>

</html>